import { Test } from '@nestjs/testing';
import { SuggestionService } from '@/core/infrastructure/adapters/services/codeBase/suggestion.service';
import { PinoLoggerService } from '@/core/infrastructure/adapters/services/logger/pino.service';
import {
    CodeSuggestion,
    SuggestionControlConfig,
    GroupingModeSuggestions,
    LimitationType
} from '@/config/types/general/codeReview.type';
import { SeverityLevel } from '@/shared/utils/enums/severityLevel.enum';
import { OrganizationAndTeamData } from '@/config/types/general/organizationAndTeamData';
import { PriorityStatus } from '@/core/domain/pullRequests/enums/priorityStatus.enum';
import { LLM_ANALYSIS_SERVICE_TOKEN } from '@/core/infrastructure/adapters/services/codeBase/llmAnalysis.service';
import { PULL_REQUESTS_SERVICE_TOKEN } from '@/core/domain/pullRequests/contracts/pullRequests.service.contracts';
import { COMMENT_MANAGER_SERVICE_TOKEN } from '@/core/domain/codeBase/contracts/CommentManagerService.contract';

describe('SuggestionService - Kody Rules Filter Control', () => {
    let service: SuggestionService;
    let mockLogger: jest.Mocked<PinoLoggerService>;

    const mockOrgData: OrganizationAndTeamData = {
        organizationId: 'org1',
        teamId: '123',
    };

    const createMockSuggestion = (severity: SeverityLevel, label: string): CodeSuggestion => ({
        id: Math.random().toString(),
        relevantFile: 'test.ts',
        language: 'typescript',
        suggestionContent: 'Test suggestion',
        improvedCode: 'improved code',
        relevantLinesStart: 1,
        relevantLinesEnd: 1,
        label,
        severity,
        priorityStatus: PriorityStatus.PRIORITIZED
    });

    beforeEach(async () => {
        mockLogger = {
            log: jest.fn(),
            error: jest.fn(),
            warn: jest.fn(),
            debug: jest.fn(),
        } as any;

        const module = await Test.createTestingModule({
            providers: [
                SuggestionService,
                { provide: PinoLoggerService, useValue: mockLogger },
                { 
                    provide: LLM_ANALYSIS_SERVICE_TOKEN, 
                    useValue: { 
                        validateImplementedSuggestions: jest.fn(),
                        filterSuggestionsSafeGuard: jest.fn(),
                        severityAnalysisAssignment: jest.fn(),
                    } 
                },
                { 
                    provide: PULL_REQUESTS_SERVICE_TOKEN, 
                    useValue: { 
                        updateSuggestion: jest.fn(),
                    } 
                },
                { 
                    provide: COMMENT_MANAGER_SERVICE_TOKEN, 
                    useValue: { 
                        repeatedCodeReviewSuggestionClustering: jest.fn(),
                        enrichParentSuggestionsWithRelated: jest.fn(),
                    } 
                },
            ],
        }).compile();

        service = module.get<SuggestionService>(SuggestionService);
    });

    describe('üéØ Controle de Filtros para Kody Rules', () => {
        it('deve aplicar filtros nas Kody Rules quando applyFiltersToKodyRules = true', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 2,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: true, // ‚úÖ Aplicar filtros
            };

            const suggestions = [
                createMockSuggestion(SeverityLevel.LOW, 'kody_rules'),      // ‚ùå Filtrado por severidade
                createMockSuggestion(SeverityLevel.HIGH, 'kody_rules'),     // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.CRITICAL, 'kody_rules'), // ‚úÖ Passa  
                createMockSuggestion(SeverityLevel.HIGH, 'security'),       // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.LOW, 'security'),        // ‚ùå Filtrado por severidade
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestions);

            // Deve aplicar filtros: severidade + quantidade (max 2)
            expect(result.prioritizedSuggestions).toHaveLength(2);
            expect(result.discardedSuggestionsBySeverityOrQuantity).toHaveLength(3);
            
            // Kody Rules de severidade baixa devem ter sido filtradas
            const kodyRulesDiscarded = result.discardedSuggestionsBySeverityOrQuantity.filter(s => s.label === 'kody_rules');
            expect(kodyRulesDiscarded).toHaveLength(1);
            expect(kodyRulesDiscarded[0].severity).toBe(SeverityLevel.LOW);
        });

        it('deve N√ÉO aplicar filtros nas Kody Rules quando applyFiltersToKodyRules = false', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 2,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: false, // ‚úÖ N√ÉO aplicar filtros
            };

            const suggestions = [
                createMockSuggestion(SeverityLevel.LOW, 'kody_rules'),      // ‚úÖ Passa (filtros ignorados)
                createMockSuggestion(SeverityLevel.HIGH, 'kody_rules'),     // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.HIGH, 'security'),       // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.LOW, 'security'),        // ‚ùå Filtrado por severidade
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestions);

            // Kody Rules passam todas, outros s√£o filtrados
            const kodyRulesPrioritized = result.prioritizedSuggestions.filter(s => s.label === 'kody_rules');
            const securityPrioritized = result.prioritizedSuggestions.filter(s => s.label === 'security');
            
            expect(kodyRulesPrioritized).toHaveLength(2); // Todas as Kody Rules passaram
            expect(securityPrioritized).toHaveLength(1);  // Apenas security HIGH passou
            
            // Verifica que security LOW foi descartada, mas nenhuma Kody Rule
            const kodyRulesDiscarded = result.discardedSuggestionsBySeverityOrQuantity.filter(s => s.label === 'kody_rules');
            expect(kodyRulesDiscarded).toHaveLength(0); // Nenhuma Kody Rule descartada
        });

        it('deve usar padr√£o (false) quando applyFiltersToKodyRules n√£o est√° definido', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 5,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.CRITICAL,
                // applyFiltersToKodyRules n√£o definido (undefined)
            };

            const suggestions = [
                createMockSuggestion(SeverityLevel.LOW, 'kody_rules'),    // ‚úÖ Passa (filtros ignorados)
                createMockSuggestion(SeverityLevel.CRITICAL, 'security'), // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.HIGH, 'security'),     // ‚ùå Filtrado por severidade
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestions);

            // Kody Rules sempre passam quando filtros n√£o s√£o aplicados (padr√£o)
            const kodyRulesPrioritized = result.prioritizedSuggestions.filter(s => s.label === 'kody_rules');
            expect(kodyRulesPrioritized).toHaveLength(1);
            
            // Apenas security CRITICAL passou
            const securityPrioritized = result.prioritizedSuggestions.filter(s => s.label === 'security');
            expect(securityPrioritized).toHaveLength(1);
        });

        it('deve processar sugest√µes normalmente quando n√£o h√° Kody Rules', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 2,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: false, // N√£o importa, n√£o h√° Kody Rules
            };

            const suggestions = [
                createMockSuggestion(SeverityLevel.HIGH, 'security'),       // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.CRITICAL, 'security'),   // ‚úÖ Passa
                createMockSuggestion(SeverityLevel.LOW, 'security'),        // ‚ùå Filtrado por severidade
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestions);

            // Deve usar l√≥gica original sem Kody Rules
            expect(result.prioritizedSuggestions).toHaveLength(2);
            expect(result.discardedSuggestionsBySeverityOrQuantity).toHaveLength(1);
        });

        // üêõ TESTES PARA CAPTURAR POSS√çVEIS BUGS
        it('üêõ BUG TEST: deve processar APENAS Kody Rules quando applyFiltersToKodyRules = false', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 2,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: false, // ‚úÖ Kody Rules isentas
            };

            // ‚ö†Ô∏è CEN√ÅRIO CR√çTICO: S√≥ Kody Rules, nenhuma sugest√£o normal
            const suggestions = [
                createMockSuggestion(SeverityLevel.LOW, 'kody_rules'),     // ‚úÖ Deve passar (isenta)
                createMockSuggestion(SeverityLevel.MEDIUM, 'kody_rules'),  // ‚úÖ Deve passar (isenta)
                createMockSuggestion(SeverityLevel.HIGH, 'kody_rules'),    // ‚úÖ Deve passar (isenta)
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestions);

            // üêõ ESTE TESTE PODE FALHAR SE HOUVER BUG
            expect(result.prioritizedSuggestions).toHaveLength(3); // Todas as Kody Rules devem passar
            expect(result.discardedSuggestionsBySeverityOrQuantity).toHaveLength(0); // Nenhuma descartada

            // Verificar que todas s√£o Kody Rules
            result.prioritizedSuggestions.forEach(s => {
                expect(s.label).toBe('kody_rules');
                expect(s.priorityStatus).toBe(PriorityStatus.PRIORITIZED);
            });
        });

        it('üêõ BUG TEST: deve detectar Kody Rules com label normalizado', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 5,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: false,
            };

            // ‚ö†Ô∏è TESTE: Labels que podem vir de diferentes fontes
            const suggestionsWithVariedLabels = [
                { ...createMockSuggestion(SeverityLevel.LOW, 'kody_rules'), id: '1' },        // Exato
                { ...createMockSuggestion(SeverityLevel.LOW, 'Kody Rules'), id: '2' },        // Capitalizado (AI)
                { ...createMockSuggestion(SeverityLevel.LOW, 'KODY_RULES'), id: '3' },        // Mai√∫sculo  
                { ...createMockSuggestion(SeverityLevel.LOW, 'security'), id: '4' },          // Normal
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestionsWithVariedLabels);

            // üêõ VERIFICA SE DETECTA KODY RULES EM QUALQUER FORMATO
            const kodyRulesDetected = suggestionsWithVariedLabels.some(s => s.label === 'kody_rules' || s.label === 'Kody Rules' || s.label === 'KODY_RULES');
            
            if (kodyRulesDetected) {
                // Deve usar l√≥gica de Kody Rules
                const kodyRulesInResult = result.prioritizedSuggestions.filter(s => 
                    s.label === 'kody_rules' || s.label === 'Kody Rules' || s.label === 'KODY_RULES'
                );
                expect(kodyRulesInResult.length).toBeGreaterThan(0); // Alguma Kody Rule deve aparecer
            }
        });

        it('üêõ BUG TEST: deve funcionar com array vazio de sugest√µes', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 5,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: false,
            };

            const suggestions: any[] = []; // ‚ö†Ô∏è Array vazio

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestions);

            // üêõ N√ÉO DEVE QUEBRAR COM ARRAY VAZIO
            expect(result.prioritizedSuggestions).toHaveLength(0);
            expect(result.discardedSuggestionsBySeverityOrQuantity).toHaveLength(0);
        });

        it('üêõ BUG TEST: deve funcionar com suggestionControl undefined/null', async () => {
            const suggestions = [
                createMockSuggestion(SeverityLevel.HIGH, 'kody_rules'),
                createMockSuggestion(SeverityLevel.HIGH, 'security'),
            ];

            // ‚ö†Ô∏è TESTE: Config malformada
            const malformedConfig = {
                maxSuggestions: 5,
                // applyFiltersToKodyRules: undefined (missing)
            } as any;

            // üêõ N√ÉO DEVE QUEBRAR COM CONFIG MALFORMADA
            expect(async () => {
                await service.prioritizeSuggestions(mockOrgData, malformedConfig, 123, suggestions);
            }).not.toThrow();
        });

        it('üî• CRITICAL BUG: falha em detectar Kody Rules com labels n√£o normalizados', async () => {
            const suggestionControl: SuggestionControlConfig = {
                maxSuggestions: 2,
                limitationType: LimitationType.PR,
                groupingMode: GroupingModeSuggestions.MINIMAL,
                severityLevelFilter: SeverityLevel.HIGH,
                applyFiltersToKodyRules: false, // ‚úÖ Kody Rules deveriam ser isentas
            };

            // üî• CEN√ÅRIO: Kody Rules com labels capitalizados (vem da IA assim)
            const suggestionsWithNonNormalizedLabels = [
                { ...createMockSuggestion(SeverityLevel.LOW, 'Kody Rules'), id: '1' },     // ‚úÖ Deve passar (isenta)
                { ...createMockSuggestion(SeverityLevel.HIGH, 'security'), id: '2' },       // ‚úÖ Deve passar (severidade)
            ];

            const result = await service.prioritizeSuggestions(mockOrgData, suggestionControl, 123, suggestionsWithNonNormalizedLabels);

            // ‚úÖ VALIDA√á√ïES: Ambas devem passar
            expect(result.prioritizedSuggestions).toHaveLength(2);
            expect(result.discardedSuggestionsBySeverityOrQuantity).toHaveLength(0);

            // ‚úÖ Verificar que Kody Rules foi detectada e passou
            const kodyRulesInResult = result.prioritizedSuggestions.find(s => s.label === 'Kody Rules');
            expect(kodyRulesInResult).toBeDefined();
            expect(kodyRulesInResult.severity).toBe('low'); // LOW passou porque foi isenta
        });

        it('deve normalizar labels corretamente', () => {
            expect(service.normalizeLabel('Kody Rules')).toBe('kody_rules');
            expect(service.normalizeLabel('CODE_STYLE')).toBe('code_style');
            expect(service.normalizeLabel('  test  ')).toBe('_test_');
            expect(service.normalizeLabel('')).toBe('');
            expect(service.normalizeLabel('Performance and Optimization')).toBe('performance_and_optimization');
        });
    });
}); 