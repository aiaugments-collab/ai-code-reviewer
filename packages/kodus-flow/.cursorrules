# ğŸ¯ CURSOR RULES - KODUS FLOW ARCHITECTURE

## ğŸ“‹ **CONTEXTO DO PROJETO**

O **Kodus Flow** Ã© um framework enterprise para orquestraÃ§Ã£o de agentes de IA com arquitetura em **5 camadas bem definidas**. Cada camada tem responsabilidades especÃ­ficas e **NÃƒO deve interferir nas outras**.

## ğŸš« **REGRAS CRÃTICAS**

### **1. NUNCA Acesse Camadas Diretamente**

- âŒ NÃƒO acesse Runtime da Engine
- âŒ NÃƒO acesse Kernel da Runtime
- âŒ NÃƒO acesse Engine da Orchestration
- âœ… SEMPRE use comunicaÃ§Ã£o permitida

### **2. NUNCA Duplique Funcionalidades**

- âŒ NÃƒO crie novo sistema de eventos na Engine
- âŒ NÃƒO crie novo sistema de contexto na Runtime
- âŒ NÃƒO crie novo logger
- âœ… SEMPRE use sistemas existentes

### **3. NUNCA Mude Responsabilidades**

- âŒ NÃƒO faÃ§a Engine processar eventos
- âŒ NÃƒO faÃ§a Runtime gerenciar contexto
- âŒ NÃƒO faÃ§a Kernel executar agentes
- âœ… SEMPRE mantenha responsabilidades da camada

## ğŸ¯ **CAMADAS E RESPONSABILIDADES**

### **ORCHESTRATION LAYER** (`src/orchestration/`)

- **Responsabilidade**: API simples para usuÃ¡rio
- **Pode usar**: Engine, Observability
- **NÃƒO pode usar**: Runtime, Kernel
- **Exemplo**: `orchestration.createAgent()`, `orchestration.callAgent()`

### **ENGINE LAYER** (`src/engine/`)

- **Responsabilidade**: Executar agentes, tools, workflows
- **Pode usar**: Kernel, Runtime\* (apenas AgentExecutor), Observability
- **NÃƒO pode usar**: -
- **Exemplo**: `AgentEngine.execute()`, `AgentExecutor.executeViaWorkflow()`

### **KERNEL LAYER** (`src/kernel/`)

- **Responsabilidade**: Gerenciar contexto, estado, isolamento
- **Pode usar**: Runtime, Observability
- **NÃƒO pode usar**: -
- **Exemplo**: `kernel.setContext()`, `kernel.pause()`, `kernel.resume()`

### **RUNTIME LAYER** (`src/runtime/`)

- **Responsabilidade**: Processar eventos e streams
- **Pode usar**: Observability
- **NÃƒO pode usar**: Kernel, Engine
- **Exemplo**: `runtime.emit()`, `runtime.on()`, `createRuntime()`

### **OBSERVABILITY LAYER** (`src/observability/`)

- **Responsabilidade**: Logging, telemetry, monitoring
- **Pode usar**: -
- **NÃƒO pode usar**: Todas as outras
- **Exemplo**: `createLogger()`, `getTelemetry()`, `getLayeredMetricsSystem()`

## âœ… **PADRÃ•ES CORRETOS**

### **Criando Componente**

```typescript
// âœ… SEMPRE identifique a camada primeiro
// âœ… SEMPRE use comunicaÃ§Ã£o permitida
// âœ… SEMPRE use observabilidade

// Se criando API â†’ ORCHESTRATION
// Se executando agentes â†’ ENGINE
// Se gerenciando contexto â†’ KERNEL
// Se processando eventos â†’ RUNTIME
// Se observando â†’ OBSERVABILITY
```

### **Adicionando Logging**

```typescript
// âœ… CORRETO
this.logger = createLogger('my-component');
this.logger.info('Operation started', { correlationId: 'corr-123' });

// âŒ ERRADO
console.log('Operation started');
```

### **Gerenciando Contexto**

```typescript
// âœ… CORRETO (se enableKernelIntegration=true)
if (this.config.enableKernelIntegration) {
    this.kernelHandler.setContext('agent', 'state', { status: 'running' });
}

// âŒ ERRADO
this.context = {};
```

### **Processando Eventos**

```typescript
// âœ… CORRETO (apenas AgentExecutor)
if (agentInstance instanceof AgentExecutor) {
    await this.runtime.emit('agent.execution.started', {
        agentName: 'my-agent',
    });
}

// âŒ ERRADO (AgentEngine)
this.runtime = createRuntime(); // NÃƒO FAÃ‡A ISSO
```

## ğŸš€ **EXEMPLOS PRÃTICOS**

### **Criando Novo Agente**

```typescript
// âœ… CORRETO: Usar Orchestration
orchestration.createAgent({
    name: 'my-new-agent',
    think: async (input) => ({
        reasoning: '...',
        action: { type: 'final_answer', content: input },
    }),
});

// âŒ ERRADO: Acessar Engine diretamente
const agent = new AgentEngine(); // NÃƒO FAÃ‡A ISSO
```

### **Adicionando Tool**

```typescript
// âœ… CORRETO: Usar Orchestration
orchestration.createTool({
    name: 'calculator',
    execute: async (input) => ({ result: eval(input.expression) }),
});

// âŒ ERRADO: Acessar ToolEngine diretamente
const toolEngine = new ToolEngine(); // NÃƒO FAÃ‡A ISSO
```

### **Gerenciando Estado**

```typescript
// âœ… CORRETO: Usar Kernel
kernel.setContext('user', 'preferences', { language: 'typescript' });

// âŒ ERRADO: Gerenciar estado diretamente
this.state = {}; // NÃƒO FAÃ‡A ISSO
```

## ğŸ“‹ **RESUMO RÃPIDO**

| Camada            | Responsabilidade   | Pode Usar                        | NÃƒO Pode Usar   |
| ----------------- | ------------------ | -------------------------------- | --------------- |
| **Orchestration** | API simples        | Engine, Observability            | Runtime, Kernel |
| **Engine**        | Executar agentes   | Kernel, Runtime\*, Observability | -               |
| **Kernel**        | Contexto e estado  | Runtime, Observability           | -               |
| **Runtime**       | Processar eventos  | Observability                    | Kernel, Engine  |
| **Observability** | Logging, telemetry | -                                | Todas as outras |

\*Runtime apenas para AgentExecutor, nÃ£o para AgentEngine

## ğŸ¯ **LEMBRE-SE**

1. **SEMPRE** identifique a camada antes de implementar
2. **SEMPRE** use comunicaÃ§Ã£o permitida
3. **SEMPRE** use observabilidade
4. **NUNCA** acesse camadas diretamente
5. **NUNCA** duplique funcionalidades
6. **NUNCA** mude responsabilidades

Esta arquitetura garante **separaÃ§Ã£o clara**, **comunicaÃ§Ã£o bem definida** e **escalabilidade enterprise**. **RESPEITE AS REGRAS** para manter a integridade do framework.

---

# ğŸ¯ **TYPESCRIPT 2025 - BOAS PRÃTICAS**

## ğŸ“‹ **PRINCÃPIOS FUNDAMENTAIS**

### **1. Simplicidade > Complexidade**

```ts
// âœ… String simples (prÃ¡tico)
type UserId = string;
type TenantId = string;
type CorrelationId = string;

// âŒ Branded types (over-engineering)
type UserId = Brand<string, 'UserId'>;
```

### **2. Co-location (Tipos prÃ³ximos ao uso)**

```ts
// âœ… Componente com seus tipos
// src/components/UserCard/UserCard.tsx
interface UserCardProps {
    user: User;
    onEdit?: () => void;
}

export const UserCard = ({ user, onEdit }: UserCardProps) => {
    // implementaÃ§Ã£o
};
```

### **3. Feature-based Organization**

```
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ types.ts
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ hooks/
â”‚   â””â”€â”€ agents/
â”‚       â”œâ”€â”€ types.ts
â”‚       â””â”€â”€ components/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â””â”€â”€ common.ts
â”‚   â””â”€â”€ utils/
â””â”€â”€ components/
    â””â”€â”€ ui/
        â”œâ”€â”€ Button/
        â”‚   â”œâ”€â”€ Button.tsx
        â”‚   â””â”€â”€ types.ts
        â””â”€â”€ Modal/
            â”œâ”€â”€ Modal.tsx
            â””â”€â”€ types.ts
```

## ğŸ¯ **TIPOS BÃSICOS E AVANÃ‡ADOS**

### **1. Interfaces vs Types**

```ts
// âœ… Interface - Para objetos extensÃ­veis
interface User {
    name: string;
    email: string;
}

interface User {
    age?: number; // âœ… Pode estender
}

// âœ… Type - Para unions, intersections
type UserRole = 'admin' | 'user' | 'guest';
type AdminUser = User & { role: 'admin' };
```

### **2. Discriminated Unions**

```ts
// âœ… State management limpo
type LoadingState = { status: 'loading' };
type SuccessState<T> = { status: 'success'; data: T };
type ErrorState = { status: 'error'; error: string };

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

// âœ… Pattern matching
const handleState = <T>(state: AsyncState<T>) => {
    switch (state.status) {
        case 'loading':
            return 'Loading...';
        case 'success':
            return state.data;
        case 'error':
            return state.error;
    }
};
```

### **3. Utility Types**

```ts
// âœ… ReutilizaÃ§Ã£o inteligente
type CreateUser = Omit<User, 'id'>;
type UserUpdate = Partial<User>;
type UserRequired = Required<Pick<User, 'name' | 'email'>>;

// âœ… Mapped Types
type Optional<T> = {
    [K in keyof T]?: T[K];
};

type Readonly<T> = {
    readonly [K in keyof T]: T[K];
};
```

### **4. Generics**

```ts
// âœ… ReutilizÃ¡vel
function identity<T>(arg: T): T {
    return arg;
}

// âœ… Classes genÃ©ricas
class Container<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }
}

// âœ… Constraints
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}
```

### **5. Template Literal Types**

```ts
// âœ… URLs tipadas
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type ApiEndpoint = `${HttpMethod} /api/${string}`;

// âœ… CSS Units
type CssUnit = `${number}px` | `${number}em` | `${number}rem`;
type CssColor = `#${string}` | `rgb(${number}, ${number}, ${number})`;
```

## ğŸ”§ **PADRÃ•ES AVANÃ‡ADOS**

### **1. Type Guards**

```ts
// âœ… Runtime type checking
function isString(value: unknown): value is string {
    return typeof value === 'string';
}

function isUser(obj: unknown): obj is User {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        'name' in obj &&
        'email' in obj
    );
}

// âœ… Discriminated union guards
function isSuccessState<T>(state: AsyncState<T>): state is SuccessState<T> {
    return state.status === 'success';
}
```

### **2. Builder Pattern**

```ts
// âœ… Query Builder Tipado
class QueryBuilder<T> {
    private query: Partial<T> = {};

    where<K extends keyof T>(key: K, value: T[K]): this {
        this.query[key] = value;
        return this;
    }

    build(): T {
        return this.query as T;
    }
}
```

### **3. Conditional Types**

```ts
// âœ… Type Guards Inteligentes
type IsArray<T> = T extends readonly any[] ? true : false;
type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;

// âœ… Mapped Types Condicionais
type OptionalProps<T> = {
    [K in keyof T as T[K] extends undefined ? never : K]: T[K];
};
```

### **4. Recursive Types**

```ts
// âœ… JSON Schema Types
type JsonValue =
    | string
    | number
    | boolean
    | null
    | JsonValue[]
    | { [key: string]: JsonValue };

// âœ… Tree Structures
type TreeNode<T> = {
    value: T;
    children: TreeNode<T>[];
};
```

## ğŸ¯ **VALIDAÃ‡ÃƒO E RUNTIME SAFETY**

### **1. TypeScript Nativo (Recomendado)**

```ts
// âœ… Simples e eficiente
interface User {
    name: string;
    email: string;
}

// âœ… ValidaÃ§Ã£o manual quando necessÃ¡rio
const validateUser = (data: unknown): data is User => {
    return (
        typeof data === 'object' &&
        data !== null &&
        'name' in data &&
        'email' in data &&
        typeof (data as any).name === 'string' &&
        typeof (data as any).email === 'string'
    );
};
```

### **2. Alternativas Modernas**

```ts
// âœ… Valibot (1.5kb - leve)
import { object, string, parse } from 'valibot';

const UserSchema = object({
    name: string(),
    email: string(),
});

type User = Input<typeof UserSchema>;
const user = parse(UserSchema, data);

// âœ… TypeBox (Schema-first)
import { Type } from '@sinclair/typebox';

const UserSchema = Type.Object({
    name: Type.String(),
    email: Type.String(),
});

type User = Static<typeof UserSchema>;
```

## ğŸ—ï¸ **ORGANIZAÃ‡ÃƒO DE PROJETOS**

### **1. Estrutura Recomendada**

```
src/
â”œâ”€â”€ features/           # OrganizaÃ§Ã£o por domÃ­nio
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ types.ts
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ hooks/
â”‚   â””â”€â”€ agents/
â”‚       â”œâ”€â”€ types.ts
â”‚       â””â”€â”€ components/
â”œâ”€â”€ shared/            # Tipos compartilhados
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â””â”€â”€ common.ts
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ components/        # Componentes UI
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ Button/
â”‚       â”‚   â”œâ”€â”€ Button.tsx
â”‚       â”‚   â””â”€â”€ types.ts
â”‚       â””â”€â”€ Modal/
â”‚           â”œâ”€â”€ Modal.tsx
â”‚           â””â”€â”€ types.ts
â””â”€â”€ types/            # Tipos globais
    â”œâ”€â”€ index.ts
    â”œâ”€â”€ api.ts
    â””â”€â”€ common.ts
```

### **2. Barrel Exports**

```ts
// âœ… src/features/auth/index.ts
export * from './types';
export * from './components';
export * from './hooks';

// âœ… src/shared/types/index.ts
export * from './api';
export * from './common';
export * from './utils';
```

### **3. Co-location Strategy**

```ts
// âœ… Tipos prÃ³ximos ao uso
// src/features/auth/components/LoginForm.tsx
interface LoginFormProps {
    onSubmit: (credentials: LoginCredentials) => void;
}

// src/features/auth/types.ts
interface LoginCredentials {
    email: string;
    password: string;
}
```

## ğŸ¯ **PADRÃ•ES PARA FRAMEWORK ENTERPRISE**

### **1. Contextos Base**

```ts
// âœ… Base simples
interface BaseContext {
    tenantId: string;
    correlationId: string;
}

// âœ… ExtensÃµes especÃ­ficas
interface AgentContext extends BaseContext {
    agentName: string;
    invocationId: string;
    stateManager: ContextStateService;
    availableTools: Tool[];
    signal: AbortSignal;
}
```

### **2. Actions/Events**

```ts
// âœ… Discriminated unions
type AgentAction =
    | { type: 'start'; agentName: string }
    | { type: 'stop'; reason?: string }
    | { type: 'pause'; saveState: boolean }
    | { type: 'resume'; snapshotId?: string };

// âœ… Event handling
type AgentEvent =
    | { type: 'agent.started'; agentName: string; timestamp: number }
    | { type: 'agent.stopped'; agentName: string; reason: string }
    | { type: 'agent.error'; agentName: string; error: string };
```

### **3. State Management**

```ts
// âœ… Estados tipados
type AgentState =
    | { status: 'idle' }
    | { status: 'starting'; agentName: string }
    | { status: 'running'; startTime: number; agentName: string }
    | { status: 'paused'; pauseTime: number; agentName: string }
    | { status: 'error'; error: string; agentName: string };

// âœ… Async states
type AsyncState<T> =
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: string };
```

## âŒ **EVITAR**

1. **Branded types** (a menos que seja crÃ­tico)
2. **Over-engineering** de tipos simples
3. **Any** (use `unknown` + type guards)
4. **Type assertions** desnecessÃ¡rias
5. **Complexidade** desnecessÃ¡ria
6. **Zod** para projetos simples (use TypeScript nativo)

## âœ… **PREFERIR**

1. **String simples** para IDs
2. **Discriminated unions** para estados
3. **Co-location** para organizaÃ§Ã£o
4. **Utility types** para reutilizaÃ§Ã£o
5. **Type guards** para runtime safety
6. **Simplicidade** sobre complexidade
7. **TypeScript nativo** para validaÃ§Ã£o

## ğŸ¯ **CONFIGURAÃ‡ÃƒO RECOMENDADA**

### tsconfig.json

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "ESNext",
        "moduleResolution": "bundler",
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "noUncheckedIndexedAccess": true,
        "exactOptionalPropertyTypes": true,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "allowUnusedLabels": false,
        "allowUnreachableCode": false
    }
}
```

## ğŸš€ **TRENDS 2025**

1. **Runtime Type Safety**: Valibot, TypeBox (leves)
2. **Compile-time Validation**: Elysia, Bun
3. **Template Literal Types**: URLs, CSS, APIs tipadas
4. **Discriminated Unions**: State management
5. **Utility Types**: ReutilizaÃ§Ã£o de tipos
6. **Type Guards**: Runtime safety
7. **Simplicidade**: Menos over-engineering

## ğŸ¯ **DECISÃƒO FINAL PARA KODUS FLOW**

**Para Framework Enterprise:**

- **String** para todos os IDs
- **Discriminated unions** para estados
- **Co-location** para organizaÃ§Ã£o
- **TypeScript nativo** para validaÃ§Ã£o
- **Simplicidade** sobre complexidade
- **Feature-based** para escalabilidade

**Resumo**: TypeScript Ã© sobre **type safety** + **developer experience** + **performance**. Use o que faz sentido para seu projeto, nÃ£o over-engineer!
