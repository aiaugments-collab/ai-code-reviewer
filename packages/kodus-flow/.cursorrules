# 🎯 CURSOR RULES - KODUS FLOW ARCHITECTURE

## 📋 **CONTEXTO DO PROJETO**

O **Kodus Flow** é um framework enterprise para orquestração de agentes de IA com arquitetura em **5 camadas bem definidas**. Cada camada tem responsabilidades específicas e **NÃO deve interferir nas outras**.

## 🚫 **REGRAS CRÍTICAS**

### **1. NUNCA Acesse Camadas Diretamente**

- ❌ NÃO acesse Runtime da Engine
- ❌ NÃO acesse Kernel da Runtime
- ❌ NÃO acesse Engine da Orchestration
- ✅ SEMPRE use comunicação permitida

### **2. NUNCA Duplique Funcionalidades**

- ❌ NÃO crie novo sistema de eventos na Engine
- ❌ NÃO crie novo sistema de contexto na Runtime
- ❌ NÃO crie novo logger
- ✅ SEMPRE use sistemas existentes

### **3. NUNCA Mude Responsabilidades**

- ❌ NÃO faça Engine processar eventos
- ❌ NÃO faça Runtime gerenciar contexto
- ❌ NÃO faça Kernel executar agentes
- ✅ SEMPRE mantenha responsabilidades da camada

## 🎯 **CAMADAS E RESPONSABILIDADES**

### **ORCHESTRATION LAYER** (`src/orchestration/`)

- **Responsabilidade**: API simples para usuário
- **Pode usar**: Engine, Observability
- **NÃO pode usar**: Runtime, Kernel
- **Exemplo**: `orchestration.createAgent()`, `orchestration.callAgent()`

### **ENGINE LAYER** (`src/engine/`)

- **Responsabilidade**: Executar agentes, tools, workflows
- **Pode usar**: Kernel, Runtime\* (apenas AgentExecutor), Observability
- **NÃO pode usar**: -
- **Exemplo**: `AgentEngine.execute()`, `AgentExecutor.executeViaWorkflow()`

### **KERNEL LAYER** (`src/kernel/`)

- **Responsabilidade**: Gerenciar contexto, estado, isolamento
- **Pode usar**: Runtime, Observability
- **NÃO pode usar**: -
- **Exemplo**: `kernel.setContext()`, `kernel.pause()`, `kernel.resume()`

### **RUNTIME LAYER** (`src/runtime/`)

- **Responsabilidade**: Processar eventos e streams
- **Pode usar**: Observability
- **NÃO pode usar**: Kernel, Engine
- **Exemplo**: `runtime.emit()`, `runtime.on()`, `createRuntime()`

### **OBSERVABILITY LAYER** (`src/observability/`)

- **Responsabilidade**: Logging, telemetry, monitoring
- **Pode usar**: -
- **NÃO pode usar**: Todas as outras
- **Exemplo**: `createLogger()`, `getTelemetry()`, `getLayeredMetricsSystem()`

## ✅ **PADRÕES CORRETOS**

### **Criando Componente**

```typescript
// ✅ SEMPRE identifique a camada primeiro
// ✅ SEMPRE use comunicação permitida
// ✅ SEMPRE use observabilidade

// Se criando API → ORCHESTRATION
// Se executando agentes → ENGINE
// Se gerenciando contexto → KERNEL
// Se processando eventos → RUNTIME
// Se observando → OBSERVABILITY
```

### **Adicionando Logging**

```typescript
// ✅ CORRETO
this.logger = createLogger('my-component');
this.logger.info('Operation started', { correlationId: 'corr-123' });

// ❌ ERRADO
console.log('Operation started');
```

### **Gerenciando Contexto**

```typescript
// ✅ CORRETO (se enableKernelIntegration=true)
if (this.config.enableKernelIntegration) {
    this.kernelHandler.setContext('agent', 'state', { status: 'running' });
}

// ❌ ERRADO
this.context = {};
```

### **Processando Eventos**

```typescript
// ✅ CORRETO (apenas AgentExecutor)
if (agentInstance instanceof AgentExecutor) {
    await this.runtime.emit('agent.execution.started', {
        agentName: 'my-agent',
    });
}

// ❌ ERRADO (AgentEngine)
this.runtime = createRuntime(); // NÃO FAÇA ISSO
```

## 🚀 **EXEMPLOS PRÁTICOS**

### **Criando Novo Agente**

```typescript
// ✅ CORRETO: Usar Orchestration
orchestration.createAgent({
    name: 'my-new-agent',
    think: async (input) => ({
        reasoning: '...',
        action: { type: 'final_answer', content: input },
    }),
});

// ❌ ERRADO: Acessar Engine diretamente
const agent = new AgentEngine(); // NÃO FAÇA ISSO
```

### **Adicionando Tool**

```typescript
// ✅ CORRETO: Usar Orchestration
orchestration.createTool({
    name: 'calculator',
    execute: async (input) => ({ result: eval(input.expression) }),
});

// ❌ ERRADO: Acessar ToolEngine diretamente
const toolEngine = new ToolEngine(); // NÃO FAÇA ISSO
```

### **Gerenciando Estado**

```typescript
// ✅ CORRETO: Usar Kernel
kernel.setContext('user', 'preferences', { language: 'typescript' });

// ❌ ERRADO: Gerenciar estado diretamente
this.state = {}; // NÃO FAÇA ISSO
```

## 📋 **RESUMO RÁPIDO**

| Camada            | Responsabilidade   | Pode Usar                        | NÃO Pode Usar   |
| ----------------- | ------------------ | -------------------------------- | --------------- |
| **Orchestration** | API simples        | Engine, Observability            | Runtime, Kernel |
| **Engine**        | Executar agentes   | Kernel, Runtime\*, Observability | -               |
| **Kernel**        | Contexto e estado  | Runtime, Observability           | -               |
| **Runtime**       | Processar eventos  | Observability                    | Kernel, Engine  |
| **Observability** | Logging, telemetry | -                                | Todas as outras |

\*Runtime apenas para AgentExecutor, não para AgentEngine

## 🎯 **LEMBRE-SE**

1. **SEMPRE** identifique a camada antes de implementar
2. **SEMPRE** use comunicação permitida
3. **SEMPRE** use observabilidade
4. **NUNCA** acesse camadas diretamente
5. **NUNCA** duplique funcionalidades
6. **NUNCA** mude responsabilidades

Esta arquitetura garante **separação clara**, **comunicação bem definida** e **escalabilidade enterprise**. **RESPEITE AS REGRAS** para manter a integridade do framework.

---

# 🎯 **TYPESCRIPT 2025 - BOAS PRÁTICAS**

## 📋 **PRINCÍPIOS FUNDAMENTAIS**

### **1. Simplicidade > Complexidade**

```ts
// ✅ String simples (prático)
type UserId = string;
type TenantId = string;
type CorrelationId = string;

// ❌ Branded types (over-engineering)
type UserId = Brand<string, 'UserId'>;
```

### **2. Co-location (Tipos próximos ao uso)**

```ts
// ✅ Componente com seus tipos
// src/components/UserCard/UserCard.tsx
interface UserCardProps {
    user: User;
    onEdit?: () => void;
}

export const UserCard = ({ user, onEdit }: UserCardProps) => {
    // implementação
};
```

### **3. Feature-based Organization**

```
src/
├── features/
│   ├── auth/
│   │   ├── types.ts
│   │   ├── components/
│   │   └── hooks/
│   └── agents/
│       ├── types.ts
│       └── components/
├── shared/
│   ├── types/
│   │   ├── api.ts
│   │   └── common.ts
│   └── utils/
└── components/
    └── ui/
        ├── Button/
        │   ├── Button.tsx
        │   └── types.ts
        └── Modal/
            ├── Modal.tsx
            └── types.ts
```

## 🎯 **TIPOS BÁSICOS E AVANÇADOS**

### **1. Interfaces vs Types**

```ts
// ✅ Interface - Para objetos extensíveis
interface User {
    name: string;
    email: string;
}

interface User {
    age?: number; // ✅ Pode estender
}

// ✅ Type - Para unions, intersections
type UserRole = 'admin' | 'user' | 'guest';
type AdminUser = User & { role: 'admin' };
```

### **2. Discriminated Unions**

```ts
// ✅ State management limpo
type LoadingState = { status: 'loading' };
type SuccessState<T> = { status: 'success'; data: T };
type ErrorState = { status: 'error'; error: string };

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

// ✅ Pattern matching
const handleState = <T>(state: AsyncState<T>) => {
    switch (state.status) {
        case 'loading':
            return 'Loading...';
        case 'success':
            return state.data;
        case 'error':
            return state.error;
    }
};
```

### **3. Utility Types**

```ts
// ✅ Reutilização inteligente
type CreateUser = Omit<User, 'id'>;
type UserUpdate = Partial<User>;
type UserRequired = Required<Pick<User, 'name' | 'email'>>;

// ✅ Mapped Types
type Optional<T> = {
    [K in keyof T]?: T[K];
};

type Readonly<T> = {
    readonly [K in keyof T]: T[K];
};
```

### **4. Generics**

```ts
// ✅ Reutilizável
function identity<T>(arg: T): T {
    return arg;
}

// ✅ Classes genéricas
class Container<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }
}

// ✅ Constraints
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}
```

### **5. Template Literal Types**

```ts
// ✅ URLs tipadas
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type ApiEndpoint = `${HttpMethod} /api/${string}`;

// ✅ CSS Units
type CssUnit = `${number}px` | `${number}em` | `${number}rem`;
type CssColor = `#${string}` | `rgb(${number}, ${number}, ${number})`;
```

## 🔧 **PADRÕES AVANÇADOS**

### **1. Type Guards**

```ts
// ✅ Runtime type checking
function isString(value: unknown): value is string {
    return typeof value === 'string';
}

function isUser(obj: unknown): obj is User {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        'name' in obj &&
        'email' in obj
    );
}

// ✅ Discriminated union guards
function isSuccessState<T>(state: AsyncState<T>): state is SuccessState<T> {
    return state.status === 'success';
}
```

### **2. Builder Pattern**

```ts
// ✅ Query Builder Tipado
class QueryBuilder<T> {
    private query: Partial<T> = {};

    where<K extends keyof T>(key: K, value: T[K]): this {
        this.query[key] = value;
        return this;
    }

    build(): T {
        return this.query as T;
    }
}
```

### **3. Conditional Types**

```ts
// ✅ Type Guards Inteligentes
type IsArray<T> = T extends readonly any[] ? true : false;
type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;

// ✅ Mapped Types Condicionais
type OptionalProps<T> = {
    [K in keyof T as T[K] extends undefined ? never : K]: T[K];
};
```

### **4. Recursive Types**

```ts
// ✅ JSON Schema Types
type JsonValue =
    | string
    | number
    | boolean
    | null
    | JsonValue[]
    | { [key: string]: JsonValue };

// ✅ Tree Structures
type TreeNode<T> = {
    value: T;
    children: TreeNode<T>[];
};
```

## 🎯 **VALIDAÇÃO E RUNTIME SAFETY**

### **1. TypeScript Nativo (Recomendado)**

```ts
// ✅ Simples e eficiente
interface User {
    name: string;
    email: string;
}

// ✅ Validação manual quando necessário
const validateUser = (data: unknown): data is User => {
    return (
        typeof data === 'object' &&
        data !== null &&
        'name' in data &&
        'email' in data &&
        typeof (data as any).name === 'string' &&
        typeof (data as any).email === 'string'
    );
};
```

### **2. Alternativas Modernas**

```ts
// ✅ Valibot (1.5kb - leve)
import { object, string, parse } from 'valibot';

const UserSchema = object({
    name: string(),
    email: string(),
});

type User = Input<typeof UserSchema>;
const user = parse(UserSchema, data);

// ✅ TypeBox (Schema-first)
import { Type } from '@sinclair/typebox';

const UserSchema = Type.Object({
    name: Type.String(),
    email: Type.String(),
});

type User = Static<typeof UserSchema>;
```

## 🏗️ **ORGANIZAÇÃO DE PROJETOS**

### **1. Estrutura Recomendada**

```
src/
├── features/           # Organização por domínio
│   ├── auth/
│   │   ├── types.ts
│   │   ├── components/
│   │   └── hooks/
│   └── agents/
│       ├── types.ts
│       └── components/
├── shared/            # Tipos compartilhados
│   ├── types/
│   │   ├── api.ts
│   │   └── common.ts
│   └── utils/
├── components/        # Componentes UI
│   └── ui/
│       ├── Button/
│       │   ├── Button.tsx
│       │   └── types.ts
│       └── Modal/
│           ├── Modal.tsx
│           └── types.ts
└── types/            # Tipos globais
    ├── index.ts
    ├── api.ts
    └── common.ts
```

### **2. Barrel Exports**

```ts
// ✅ src/features/auth/index.ts
export * from './types';
export * from './components';
export * from './hooks';

// ✅ src/shared/types/index.ts
export * from './api';
export * from './common';
export * from './utils';
```

### **3. Co-location Strategy**

```ts
// ✅ Tipos próximos ao uso
// src/features/auth/components/LoginForm.tsx
interface LoginFormProps {
    onSubmit: (credentials: LoginCredentials) => void;
}

// src/features/auth/types.ts
interface LoginCredentials {
    email: string;
    password: string;
}
```

## 🎯 **PADRÕES PARA FRAMEWORK ENTERPRISE**

### **1. Contextos Base**

```ts
// ✅ Base simples
interface BaseContext {
    tenantId: string;
    correlationId: string;
}

// ✅ Extensões específicas
interface AgentContext extends BaseContext {
    agentName: string;
    invocationId: string;
    stateManager: ContextStateService;
    availableTools: Tool[];
    signal: AbortSignal;
}
```

### **2. Actions/Events**

```ts
// ✅ Discriminated unions
type AgentAction =
    | { type: 'start'; agentName: string }
    | { type: 'stop'; reason?: string }
    | { type: 'pause'; saveState: boolean }
    | { type: 'resume'; snapshotId?: string };

// ✅ Event handling
type AgentEvent =
    | { type: 'agent.started'; agentName: string; timestamp: number }
    | { type: 'agent.stopped'; agentName: string; reason: string }
    | { type: 'agent.error'; agentName: string; error: string };
```

### **3. State Management**

```ts
// ✅ Estados tipados
type AgentState =
    | { status: 'idle' }
    | { status: 'starting'; agentName: string }
    | { status: 'running'; startTime: number; agentName: string }
    | { status: 'paused'; pauseTime: number; agentName: string }
    | { status: 'error'; error: string; agentName: string };

// ✅ Async states
type AsyncState<T> =
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: string };
```

## ❌ **EVITAR**

1. **Branded types** (a menos que seja crítico)
2. **Over-engineering** de tipos simples
3. **Any** (use `unknown` + type guards)
4. **Type assertions** desnecessárias
5. **Complexidade** desnecessária
6. **Zod** para projetos simples (use TypeScript nativo)

## ✅ **PREFERIR**

1. **String simples** para IDs
2. **Discriminated unions** para estados
3. **Co-location** para organização
4. **Utility types** para reutilização
5. **Type guards** para runtime safety
6. **Simplicidade** sobre complexidade
7. **TypeScript nativo** para validação

## 🎯 **CONFIGURAÇÃO RECOMENDADA**

### tsconfig.json

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "ESNext",
        "moduleResolution": "bundler",
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "noUncheckedIndexedAccess": true,
        "exactOptionalPropertyTypes": true,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "allowUnusedLabels": false,
        "allowUnreachableCode": false
    }
}
```

## 🚀 **TRENDS 2025**

1. **Runtime Type Safety**: Valibot, TypeBox (leves)
2. **Compile-time Validation**: Elysia, Bun
3. **Template Literal Types**: URLs, CSS, APIs tipadas
4. **Discriminated Unions**: State management
5. **Utility Types**: Reutilização de tipos
6. **Type Guards**: Runtime safety
7. **Simplicidade**: Menos over-engineering

## 🎯 **DECISÃO FINAL PARA KODUS FLOW**

**Para Framework Enterprise:**

- **String** para todos os IDs
- **Discriminated unions** para estados
- **Co-location** para organização
- **TypeScript nativo** para validação
- **Simplicidade** sobre complexidade
- **Feature-based** para escalabilidade

**Resumo**: TypeScript é sobre **type safety** + **developer experience** + **performance**. Use o que faz sentido para seu projeto, não over-engineer!
